{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assign = require(\"lodash/assign\");\n/* jshint validthis: true */\n\n\nvar is = 'is-',\n    space = ' ',\n    settings = {\n  ns: '',\n  el: '__',\n  mod: '_',\n  modValue: '_',\n  classMap: {}\n};\n/**\n * Simplest mixin helper\n */\n\nfunction extend(target, obj) {\n  return Object.keys(obj).reduce(function (target, key) {\n    var value = obj[key]; // Shallow copy of array\n\n    if (Array.isArray(value)) {\n      value = value.slice();\n    }\n\n    target[key] = value;\n    return target;\n  }, target);\n}\n/**\n * Shallow copy helper\n */\n\n\nfunction copy(obj) {\n  return extend({}, obj);\n}\n/**\n * Converts object with classes to array of strings\n * Example: objectToArray({ color: 'red' }) -> ['', '_color_red']\n *\n * @param {Object} obj { name: 'value' } or { name1: true, name2: false }\n * @param {String} [separator='_'] Separator or prefix\n */\n\n\nfunction objectToArray(obj, separator) {\n  if (separator === undefined) {\n    separator = settings.mod;\n  }\n\n  var modValueSeparator = settings.modValue;\n  return Object.keys(obj).reduce(function (array, key) {\n    var value = obj[key];\n\n    if (!value) {\n      return array;\n    }\n\n    if (value === true) {\n      array.push(separator + key);\n    } else {\n      // Makes block__elem_{modifierKey}_{modifierValue}\n      array.push(separator + key + modValueSeparator + value);\n    }\n\n    return array;\n  }, []);\n}\n/**\n * Resolves real class name from classMap\n * @param {String} name\n * @returns {String}\n */\n\n\nfunction resolveClassName(name) {\n  return settings.classMap[name] || name;\n}\n/**\n * Callable block instance\n */\n\n\nfunction callableInstance() {\n  var args = Array.prototype.slice.call(arguments),\n      context = copy(this);\n  context = args.reduce(function (context, argv) {\n    if (argv && typeof argv === 'string') {\n      context.name = context.name + settings.el + argv;\n    }\n\n    if (argv && typeof argv === 'object') {\n      context.mods.push(argv);\n    }\n\n    return context;\n  }, context);\n  return factory(context);\n}\n/**\n * Static method toString() for callable instance\n */\n\n\nfunction toString() {\n  // Add namespace\n  var name = settings.ns + this.name,\n      classList = resolveClassName(name); // Add modifiers\n\n  classList = this.mods.reduce(function (classList, modObject) {\n    var modArray = objectToArray(modObject);\n\n    if (modArray.length) {\n      modArray = modArray.map(function (mod) {\n        return resolveClassName(name + mod);\n      });\n      modArray.unshift('');\n      classList += modArray.join(space);\n    }\n\n    return classList;\n  }, classList); // Mix with another classes\n\n  if (this.mixes.length) {\n    classList += space + this.mixes.join(space);\n  } // Add states\n\n\n  var states = this.states;\n  classList = Object.keys(states).reduce(function (classList, state) {\n    return classList += states[state] ? space + is + state : '';\n  }, classList);\n  return classList;\n}\n\nfunction split() {\n  var classNames = toString.bind(this)();\n  return String.prototype.split.apply(classNames, arguments);\n}\n/**\n * Static method mix() for callable instance\n * @param {String|Array|Object} className 'class'; ['one', 'two']; {one: true, two: false}\n */\n\n\nfunction mix(className) {\n  var context = copy(this),\n      classes;\n\n  if (className) {\n    if (typeof className === 'function') {\n      classes = [className.toString()];\n    } else if (Array.isArray(className)) {\n      classes = className;\n    } else if (typeof className === 'object') {\n      classes = [className.toString()];\n    } else if (typeof className === 'string') {\n      classes = [className];\n    } else {\n      classes = objectToArray(className, '');\n    }\n\n    context.mixes = context.mixes.concat(classes);\n  }\n\n  return factory(context);\n}\n/**\n * Adds SMACSS-states: https://smacss.com/book/type-state\n * @param {Object} obj State object\n * @return {[type]} [description]\n */\n\n\nfunction state(obj) {\n  var context = copy(this),\n      states = copy(context.states);\n  extend(states, obj || {});\n  context.states = states;\n  return factory(context);\n}\n/**\n * Generator of block-functions\n * @param {Object} context Immutable context of current block\n * @return {Function}\n */\n\n\nfunction factory(context) {\n  context = extend({\n    name: '',\n    mods: [],\n    mixes: [],\n    states: {}\n  }, context || {}); // Whilst JavaScript can't create callable objects with constructors\n  // var b:any = callableInstance.bind(context);\n\n  var b = {};\n  b.el = callableInstance.bind(context);\n  b.mod = callableInstance.bind(context); // var b:any = {}\n\n  b.toString = toString.bind(context);\n  b.split = split.bind(context);\n  b.mix = mix.bind(context);\n  b.state = state.bind(context);\n  return b;\n}\n/**\n * Entry point\n * @param {String} name Block name\n * @return {Function}\n */\n\n\nfunction block(name) {\n  return factory({\n    name: name\n  });\n}\n\nexports.block = block;\n/**\n * Setup settings\n */\n\nassign(block, {\n  setup: function setup(obj) {\n    extend(settings, obj || {});\n    return block;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}